// StandardJS, should-style assertions
// GUI tests for Pagination functionality
// Generated by jinks - DO NOT EDIT manually

describe('TEI-Publisher Pagination', () => {
  beforeEach(() => {
    // Universal intercepts (loginStub, timelineStub) are automatically set up in support/e2e.js
    cy.visit('/browse.html?collection=demo')
    
    // Wait for page to stabilize and pagination to load
    cy.get('body').should('be.visible')
    cy.get('pb-paginate', { timeout: 10000 }).should('exist')
  })

  describe('Pagination Component', () => {
    it('displays pagination component with total count', () => {
      cy.get('pb-paginate')
        .should('be.visible')
        .should('have.attr', 'total')
      
      cy.get('pb-paginate')
        .invoke('attr', 'total')
        .should('not.be.empty')
        .and('not.eq', '0')
      
      // Verify found count is displayed
      cy.get('pb-paginate')
        .find('span.found[part="count"]')
        .should('exist')
        .invoke('text')
        .should('not.be.empty')
    })

    it('displays per-page configuration', () => {
      cy.get('pb-paginate')
        .should('have.attr', 'per-page')
      
      cy.get('pb-paginate')
        .invoke('attr', 'per-page')
        .then((perPage) => {
          expect(parseInt(perPage, 10)).to.be.greaterThan(0)
        })
    })

    it('verifies total documents equals pagination count', () => {
      // Get total from pagination component
      cy.get('pb-paginate')
        .invoke('attr', 'total')
        .as('totalDocuments')
      
      // Get count from found span
      cy.get('pb-paginate')
        .find('span.found[part="count"]')
        .invoke('text')
        .then((foundText) => {
          const foundNumber = parseInt(foundText.trim(), 10)
          
          cy.get('@totalDocuments').then((total) => {
            const totalNumber = parseInt(total, 10)
            expect(foundNumber).to.equal(totalNumber)
          })
        })
    })
  })

  describe('Pagination Navigation', () => {
    it('displays first page correctly', () => {
      cy.get('pb-paginate')
        .invoke('attr', 'total')
        .then((totalStr) => {
          const total = parseInt(totalStr, 10)
          if (total > 0) {
            // On first page, should have documents displayed
            cy.get('main')
              .find('.tei-fileDesc3, .collection-item, [class*="document"]')
              .should('have.length.at.least', 1)
          }
        })
    })

    it('navigates to next page when available', () => {
      cy.get('pb-paginate')
        .invoke('attr', 'total')
        .then((totalStr) => {
          const total = parseInt(totalStr, 10)
          cy.get('pb-paginate')
            .invoke('attr', 'per-page')
            .then((perPageStr) => {
              const perPage = parseInt(perPageStr, 10)
              
              if (total > perPage) {
                // There is a next page
                cy.get('pb-paginate')
                  .find('iron-icon[icon="next"]')
                  .should('exist')
                  .closest('span, button, a')
                  .should('not.have.class', 'disabled')
                  .click({ force: true })
                
                // Wait for pagination active page to update
                cy.get('pb-paginate', { timeout: 10000 })
                  .find('span.active')
                  .should('exist')
                
                // Verify we're on page 2 or later
                cy.get('pb-paginate')
                  .find('span.active')
                  .invoke('text')
                  .then((pageText) => {
                    const pageNum = parseInt(pageText.trim(), 10)
                    expect(pageNum).to.be.greaterThan(1)
                  })
              } else {
                cy.log('Not enough documents for next page test')
              }
            })
        })
    })

    it('navigates to last page and verifies document count', () => {
      cy.get('pb-paginate')
        .invoke('attr', 'total')
        .then((totalStr) => {
          const total = parseInt(totalStr, 10)
          cy.get('pb-paginate')
            .invoke('attr', 'per-page')
            .then((perPageStr) => {
              const perPage = parseInt(perPageStr, 10)
              const modulo = total % perPage
              const expectedPages = modulo === 0 ? total / perPage : Math.floor(total / perPage) + 1
              
              if (total > perPage) {
                // Navigate to last page
                cy.get('pb-paginate')
                  .find('iron-icon[icon="last-page"]')
                  .closest('span, button, a')
                  .click({ force: true })
                
                // Wait for pagination active page to update to last page and verify
                cy.get('pb-paginate', { timeout: 10000 })
                  .find('span.active')
                  .should('exist')
                  .invoke('text')
                  .then((pageText) => {
                    const pageNum = parseInt(pageText.trim(), 10)
                    expect(pageNum).to.equal(expectedPages)
                  })
                
                // Verify document count on last page
                if (modulo > 0) {
                  cy.get('main')
                    .find('.tei-fileDesc3, .collection-item, [class*="document"]')
                    .should('have.length', modulo)
                } else {
                  cy.get('main')
                    .find('.tei-fileDesc3, .collection-item, [class*="document"]')
                    .should('have.length', perPage)
                }
              } else {
                cy.log('Not enough documents for last page test')
              }
            })
        })
    })
  })

  describe('Pagination Consistency', () => {
    it('verifies documents per page matches configuration', () => {
      cy.get('pb-paginate')
        .invoke('attr', 'per-page')
        .then((perPageStr) => {
          const perPage = parseInt(perPageStr, 10)
          
          if (perPage > 0) {
            // Count documents on current page
            cy.get('main')
              .find('.tei-fileDesc3, .collection-item, [class*="document"]')
              .its('length')
              .should('be.at.most', perPage)
              .and('be.at.least', 1)
          }
        })
    })

    it('verifies pagination math consistency', () => {
      cy.get('pb-paginate')
        .invoke('attr', 'total')
        .as('total')
      
      cy.get('pb-paginate')
        .invoke('attr', 'per-page')
        .as('perPage')
      
      cy.get('@total').then((totalStr) => {
        const total = parseInt(totalStr, 10)
        
        cy.get('@perPage').then((perPageStr) => {
          const perPage = parseInt(perPageStr, 10)
          const modulo = total % perPage
          const expectedPages = modulo === 0 ? total / perPage : Math.floor(total / perPage) + 1
          
          // Verify page count is reasonable
          expect(expectedPages).to.be.greaterThan(0)
          
          // Verify total matches modulo calculation
          const calculatedTotal = (expectedPages - 1) * perPage + (modulo === 0 ? perPage : modulo)
          expect(calculatedTotal).to.equal(total)
        })
      })
    })
  })
})

