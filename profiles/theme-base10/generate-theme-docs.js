#!/usr/bin/env node

/**
 * Script to generate markdown documentation for theme settings
 * Reads config.json and schema/jinks.json to create a table of all theme properties
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const configPath = path.join(__dirname, 'config.json');
const schemaPath = path.join(__dirname, '../../schema/jinks.json');
const readmePath = path.join(__dirname, 'doc', 'README.md');

// Read JSON files
const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
const schema = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));

/**
 * Flatten a nested object into dot-notation paths
 * @param {object} obj - The object to flatten
 * @param {string} prefix - Prefix for the path
 * @returns {Array<{path: string, value: any}>} Array of path-value pairs
 */
function flattenObject(obj, prefix = '') {
    const result = [];
    
    for (const [key, value] of Object.entries(obj)) {
        const fullPath = prefix ? `${prefix}.${key}` : key;
        
        if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
            // Recursively flatten nested objects
            result.push(...flattenObject(value, fullPath));
        } else {
            // Leaf value
            result.push({ path: fullPath, value });
        }
    }
    
    return result;
}

/**
 * Get description from schema for a given path
 * @param {object} schemaObj - Schema object to search
 * @param {string[]} pathParts - Array of path parts
 * @returns {string|null} Description or null if not found
 */
function getDescriptionFromSchema(schemaObj, pathParts) {
    if (!schemaObj || !pathParts || pathParts.length === 0) {
        return null;
    }
    
    const [first, ...rest] = pathParts;
    
    // Navigate to the next level
    if (schemaObj.properties && schemaObj.properties[first]) {
        const nextSchema = schemaObj.properties[first];
        
        // If this is the last part, get its description
        if (rest.length === 0) {
            return nextSchema.description || null;
        }
        
        // Otherwise, continue navigating
        return getDescriptionFromSchema(nextSchema, rest);
    }
    
    // Check patternProperties (for dynamic keys like palettes)
    if (schemaObj.patternProperties) {
        for (const patternSchema of Object.values(schemaObj.patternProperties)) {
            if (rest.length === 0) {
                return patternSchema.description || null;
            }
            const desc = getDescriptionFromSchema(patternSchema, rest);
            if (desc) return desc;
        }
    }
    
    return null;
}

/**
 * Format value for display in markdown
 * @param {any} value - The value to format
 * @returns {string} Formatted value
 */
function formatValue(value) {
    if (value === null) {
        return '`null`';
    }
    if (value === undefined) {
        return '`undefined`';
    }
    if (typeof value === 'string') {
        return `\`"${value}"\``;
    }
    if (typeof value === 'boolean') {
        return `\`${value}\``;
    }
    if (typeof value === 'number') {
        return `\`${value}\``;
    }
    if (Array.isArray(value)) {
        return `\`[${value.length} items]\``;
    }
    if (typeof value === 'object') {
        return `\`{object}\``;
    }
    return String(value);
}

// Get theme object from config
const theme = config.theme;
if (!theme) {
    console.error('No theme object found in config.json');
    process.exit(1);
}

// Get theme schema
const themeSchema = schema.properties.theme;
if (!themeSchema) {
    console.error('No theme schema found in jinks.json');
    process.exit(1);
}

// Flatten theme object
const flattened = flattenObject(theme);

// Sort by path for better readability
flattened.sort((a, b) => a.path.localeCompare(b.path));

// Generate markdown table content
let tableContent = `| Property | Description | Default |
|----------|-------------|-------\n`;

for (const item of flattened) {
    const pathParts = item.path.split('.');
    const description = getDescriptionFromSchema(themeSchema, pathParts) || '*No description available*';
    const value = formatValue(item.value);
    
    // Escape pipe characters in description
    const escapedDescription = description.replace(/\|/g, '\\|');
    
    tableContent += `| \`${item.path}\` | ${escapedDescription} | ${value} |\n`;
}

tableContent += `\n> **Note:** Values shown are from \`profiles/theme-base10/config.json\`. Descriptions are from \`schema/jinks.json\`. This section is auto-generated by \`generate-theme-docs.js\`.\n`;

// Marker to identify the generated section (used as both start and end)
const MARKER = '<!--GENERATED-->';

// Read existing README.md
if (!fs.existsSync(readmePath)) {
    console.error(`README.md not found at: ${readmePath}`);
    process.exit(1);
}

let readmeContent = fs.readFileSync(readmePath, 'utf8');

// Check if markers exist
const markerCount = (readmeContent.match(new RegExp(MARKER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
if (markerCount === 0) {
    console.error(`Start marker \`${MARKER}\` not found in README.md`);
    process.exit(1);
}
if (markerCount < 2) {
    console.error(`End marker \`${MARKER}\` not found in README.md. Expected two markers (start and end).`);
    process.exit(1);
}

// Replace content between the two markers
// Escape special regex characters in the marker
const escapedMarker = MARKER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
const markerRegex = new RegExp(
    `(${escapedMarker})[\\s\\S]*?(${escapedMarker})`,
    'g'
);

if (markerRegex.test(readmeContent)) {
    readmeContent = readmeContent.replace(
        markerRegex,
        `$1\n\n${tableContent}\n\n$2`
    );
} else {
    console.error(`Could not find content between markers in README.md`);
    process.exit(1);
}

// Write updated README.md
fs.writeFileSync(readmePath, readmeContent, 'utf8');

console.log(`âœ“ Injected theme documentation into: ${readmePath}`);
console.log(`  Total properties: ${flattened.length}`);

